// /*!
//  * The Final Countdown for jQuery v2.2.0 (http://hilios.github.io/jQuery.countdown/)
//  * Copyright (c) 2016 Edson Hilios
//  *
//  * Permission is hereby granted, free of charge, to any person obtaining a copy of
//  * this software and associated documentation files (the "Software"), to deal in
//  * the Software without restriction, including without limitation the rights to
//  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
//  * the Software, and to permit persons to whom the Software is furnished to do so,
//  * subject to the following conditions:
//  *
//  * The above copyright notice and this permission notice shall be included in all
//  * copies or substantial portions of the Software.
//  *
//  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
//  * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
//  * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
//  * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
//  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//  */
// !(function (a) {
//   "use strict";
//   "function" == typeof define && define.amd ? define(["jquery"], a) : a(jQuery);
// })(function (a) {
//   "use strict";
//   function b(a) {
//     if (a instanceof Date) return a;
//     if (String(a).match(g))
//       return (
//         String(a).match(/^[0-9]*$/) && (a = Number(a)),
//         String(a).match(/\-/) && (a = String(a).replace(/\-/g, "/")),
//         new Date(a)
//       );
//     throw new Error("Couldn't cast `" + a + "` to a date object.");
//   }
//   function c(a) {
//     var b = a.toString().replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1");
//     return new RegExp(b);
//   }
//   function d(a) {
//     return function (b) {
//       var d = b.match(/%(-|!)?[A-Z]{1}(:[^;]+;)?/gi);
//       if (d)
//         for (var f = 0, g = d.length; f < g; ++f) {
//           var h = d[f].match(/%(-|!)?([a-zA-Z]{1})(:[^;]+;)?/),
//             j = c(h[0]),
//             k = h[1] || "",
//             l = h[3] || "",
//             m = null;
//           (h = h[2]),
//             i.hasOwnProperty(h) && ((m = i[h]), (m = Number(a[m]))),
//             null !== m &&
//               ("!" === k && (m = e(l, m)),
//               "" === k && m < 10 && (m = "0" + m.toString()),
//               (b = b.replace(j, m.toString())));
//         }
//       return (b = b.replace(/%%/, "%"));
//     };
//   }
//   function e(a, b) {
//     var c = "s",
//       d = "";
//     return (
//       a &&
//         ((a = a.replace(/(:|;|\s)/gi, "").split(/\,/)),
//         1 === a.length ? (c = a[0]) : ((d = a[0]), (c = a[1]))),
//       Math.abs(b) > 1 ? c : d
//     );
//   }
//   var f = [],
//     g = [],
//     h = { precision: 100, elapse: !1, defer: !1 };
//   g.push(/^[0-9]*$/.source),
//     g.push(/([0-9]{1,2}\/){2}[0-9]{4}( [0-9]{1,2}(:[0-9]{2}){2})?/.source),
//     g.push(/[0-9]{4}([\/\-][0-9]{1,2}){2}( [0-9]{1,2}(:[0-9]{2}){2})?/.source),
//     (g = new RegExp(g.join("|")));
//   var i = {
//       Y: "years",
//       m: "months",
//       n: "daysToMonth",
//       d: "daysToWeek",
//       w: "weeks",
//       W: "weeksToMonth",
//       H: "hours",
//       M: "minutes",
//       S: "seconds",
//       D: "totalDays",
//       I: "totalHours",
//       N: "totalMinutes",
//       T: "totalSeconds",
//     },
//     j = function (b, c, d) {
//       (this.el = b),
//         (this.$el = a(b)),
//         (this.interval = null),
//         (this.offset = {}),
//         (this.options = a.extend({}, h)),
//         (this.instanceNumber = f.length),
//         f.push(this),
//         this.$el.data("countdown-instance", this.instanceNumber),
//         d &&
//           ("function" == typeof d
//             ? (this.$el.on("update.countdown", d),
//               this.$el.on("stoped.countdown", d),
//               this.$el.on("finish.countdown", d))
//             : (this.options = a.extend({}, h, d))),
//         this.setFinalDate(c),
//         this.options.defer === !1 && this.start();
//     };
//   a.extend(j.prototype, {
//     start: function () {
//       null !== this.interval && clearInterval(this.interval);
//       var a = this;
//       this.update(),
//         (this.interval = setInterval(function () {
//           a.update.call(a);
//         }, this.options.precision));
//     },
//     stop: function () {
//       clearInterval(this.interval),
//         (this.interval = null),
//         this.dispatchEvent("stoped");
//     },
//     toggle: function () {
//       this.interval ? this.stop() : this.start();
//     },
//     pause: function () {
//       this.stop();
//     },
//     resume: function () {
//       this.start();
//     },
//     remove: function () {
//       this.stop.call(this),
//         (f[this.instanceNumber] = null),
//         delete this.$el.data().countdownInstance;
//     },
//     setFinalDate: function (a) {
//       this.finalDate = b(a);
//     },
//     update: function () {
//       if (0 === this.$el.closest("html").length) return void this.remove();
//       var b,
//         c = void 0 !== a._data(this.el, "events"),
//         d = new Date();
//       (b = this.finalDate.getTime() - d.getTime()),
//         (b = Math.ceil(b / 1e3)),
//         (b = !this.options.elapse && b < 0 ? 0 : Math.abs(b)),
//         this.totalSecsLeft !== b &&
//           c &&
//           ((this.totalSecsLeft = b),
//           (this.elapsed = d >= this.finalDate),
//           (this.offset = {
//             seconds: this.totalSecsLeft % 60,
//             minutes: Math.floor(this.totalSecsLeft / 60) % 60,
//             hours: Math.floor(this.totalSecsLeft / 60 / 60) % 24,
//             days: Math.floor(this.totalSecsLeft / 60 / 60 / 24) % 7,
//             daysToWeek: Math.floor(this.totalSecsLeft / 60 / 60 / 24) % 7,
//             daysToMonth: Math.floor(
//               (this.totalSecsLeft / 60 / 60 / 24) % 30.4368
//             ),
//             weeks: Math.floor(this.totalSecsLeft / 60 / 60 / 24 / 7),
//             weeksToMonth: Math.floor(this.totalSecsLeft / 60 / 60 / 24 / 7) % 4,
//             months: Math.floor(this.totalSecsLeft / 60 / 60 / 24 / 30.4368),
//             years: Math.abs(this.finalDate.getFullYear() - d.getFullYear()),
//             totalDays: Math.floor(this.totalSecsLeft / 60 / 60 / 24),
//             totalHours: Math.floor(this.totalSecsLeft / 60 / 60),
//             totalMinutes: Math.floor(this.totalSecsLeft / 60),
//             totalSeconds: this.totalSecsLeft,
//           }),
//           this.options.elapse || 0 !== this.totalSecsLeft
//             ? this.dispatchEvent("update")
//             : (this.stop(), this.dispatchEvent("finish")));
//     },
//     dispatchEvent: function (b) {
//       var c = a.Event(b + ".countdown");
//       (c.finalDate = this.finalDate),
//         (c.elapsed = this.elapsed),
//         (c.offset = a.extend({}, this.offset)),
//         (c.strftime = d(this.offset)),
//         this.$el.trigger(c);
//     },
//   }),
//     (a.fn.countdown = function () {
//       var b = Array.prototype.slice.call(arguments, 0);
//       return this.each(function () {
//         var c = a(this).data("countdown-instance");
//         if (void 0 !== c) {
//           var d = f[c],
//             e = b[0];
//           j.prototype.hasOwnProperty(e)
//             ? d[e].apply(d, b.slice(1))
//             : null === String(e).match(/^[$A-Z_][0-9A-Z_$]*$/i)
//             ? (d.setFinalDate.call(d, e), d.start())
//             : a.error(
//                 "Method %s does not exist on jQuery.countdown".replace(
//                   /\%s/gi,
//                   e
//                 )
//               );
//         } else new j(this, b[0], b[1]);
//       });
//     });
// });

//////////////////////////////////////////
//////////////////////////////////////////

// AMD support (Thanks to @FagnerMartinsBrack)
;(function(factory) {
  'use strict';

  if (typeof define === 'function' && define.amd) {
    define(['jquery'], factory);
  } else {
    factory(jQuery);
  }
})(function($){
  'use strict';

  var instances = [],
      matchers  = [],
      defaultOptions  = {
        precision: 100, // 0.1 seconds, used to update the DOM
        elapse: false,
        defer: false
      };
  // Miliseconds
  matchers.push(/^[0-9]*$/.source);
  // Month/Day/Year [hours:minutes:seconds]
  matchers.push(/([0-9]{1,2}\/){2}[0-9]{4}( [0-9]{1,2}(:[0-9]{2}){2})?/
    .source);
  // Year/Day/Month [hours:minutes:seconds] and
  // Year-Day-Month [hours:minutes:seconds]
  matchers.push(/[0-9]{4}([\/\-][0-9]{1,2}){2}( [0-9]{1,2}(:[0-9]{2}){2})?/
    .source);
  // Cast the matchers to a regular expression object
  matchers = new RegExp(matchers.join('|'));
  // Parse a Date formatted has String to a native object
  function parseDateString(dateString) {
    // Pass through when a native object is sent
    if(dateString instanceof Date) {
      return dateString;
    }
    // Caste string to date object
    if(String(dateString).match(matchers)) {
      // If looks like a milisecond value cast to number before
      // final casting (Thanks to @msigley)
      if(String(dateString).match(/^[0-9]*$/)) {
        dateString = Number(dateString);
      }
      // Replace dashes to slashes
      if(String(dateString).match(/\-/)) {
        dateString = String(dateString).replace(/\-/g, '/');
      }
      return new Date(dateString);
    } else {
      throw new Error('Couldn\'t cast `' + dateString +
        '` to a date object.');
    }
  }
  // Map to convert from a directive to offset object property
  var DIRECTIVE_KEY_MAP = {
    'Y': 'years',
    'm': 'months',
    'n': 'daysToMonth',
    'd': 'daysToWeek',
    'w': 'weeks',
    'W': 'weeksToMonth',
    'H': 'hours',
    'M': 'minutes',
    'S': 'seconds',
    'D': 'totalDays',
    'I': 'totalHours',
    'N': 'totalMinutes',
    'T': 'totalSeconds'
  };
  // Returns an escaped regexp from the string
  function escapedRegExp(str) {
    var sanitize = str.toString().replace(/([.?*+^$[\]\\(){}|-])/g, '\\$1');
    return new RegExp(sanitize);
  }
  // Time string formatter
  function strftime(offsetObject) {
    return function(format) {
      var directives = format.match(/%(-|!)?[A-Z]{1}(:[^;]+;)?/gi);
      if(directives) {
        for(var i = 0, len = directives.length; i < len; ++i) {
          var directive   = directives[i]
              .match(/%(-|!)?([a-zA-Z]{1})(:[^;]+;)?/),
            regexp    = escapedRegExp(directive[0]),
            modifier  = directive[1] || '',
            plural    = directive[3] || '',
            value     = null;
            // Get the key
            directive = directive[2];
          // Swap shot-versions directives
          if(DIRECTIVE_KEY_MAP.hasOwnProperty(directive)) {
            value = DIRECTIVE_KEY_MAP[directive];
            value = Number(offsetObject[value]);
          }
          if(value !== null) {
            // Pluralize
            if(modifier === '!') {
              value = pluralize(plural, value);
            }
            // Add zero-padding
            if(modifier === '') {
              if(value < 10) {
                value = '0' + value.toString();
              }
            }
            // Replace the directive
            format = format.replace(regexp, value.toString());
          }
        }
      }
      format = format.replace(/%%/, '%');
      return format;
    };
  }
  // Pluralize
  function pluralize(format, count) {
    var plural = 's', singular = '';
    if(format) {
      format = format.replace(/(:|;|\s)/gi, '').split(/\,/);
      if(format.length === 1) {
        plural = format[0];
      } else {
        singular = format[0];
        plural = format[1];
      }
    }
    // Fix #187
    if(Math.abs(count) > 1) {
      return plural;
    } else {
      return singular;
    }
  }
  // The Final Countdown
  var Countdown = function(el, finalDate, options) {
    this.el       = el;
    this.$el      = $(el);
    this.interval = null;
    this.offset   = {};
    this.options  = $.extend({}, defaultOptions);
    // console.log(this.options);
    // This helper variable is necessary to mimick the previous check for an
    // event listener on this.$el. Because of the event loop there might not
    // be a registered event listener during the first tick. In order to work
    // as expected a second tick is necessary, so that the events can be fired
    // and handled properly.
    this.firstTick = true;
    // Register this instance
    this.instanceNumber = instances.length;
    instances.push(this);
    // Save the reference
    this.$el.data('countdown-instance', this.instanceNumber);
    // Handle options or callback
    if (options) {
      // Register the callbacks when supplied
      if(typeof options === 'function') {
        this.$el.on('update.countdown', options);
        this.$el.on('stoped.countdown', options);
        this.$el.on('finish.countdown', options);
      } else {
        this.options = $.extend({}, defaultOptions, options);
      }
    }
    // Set the final date and start
    this.setFinalDate(finalDate);
    // Starts the countdown automatically unless it's defered,
    // Issue #198
    if (this.options.defer === false) {
      this.start();
    }
  };
  $.extend(Countdown.prototype, {
    start: function() {
      if(this.interval !== null) {
        clearInterval(this.interval);
      }
      var self = this;
      this.update();
      this.interval = setInterval(function() {
        self.update.call(self);
      }, this.options.precision);
    },
    stop: function() {
      clearInterval(this.interval);
      this.interval = null;
      this.dispatchEvent('stoped');
    },
    toggle: function() {
      if (this.interval) {
        this.stop();
      } else {
        this.start();
      }
    },
    pause: function() {
      this.stop();
    },
    resume: function() {
      this.start();
    },
    remove: function() {
      this.stop.call(this);
      instances[this.instanceNumber] = null;
      // Reset the countdown instance under data attr (Thanks to @assiotis)
      delete this.$el.data().countdownInstance;
    },
    setFinalDate: function(value) {
      this.finalDate = parseDateString(value); // Cast the given date
    },
    update: function() {
      // Stop if dom is not in the html (Thanks to @dleavitt)
      if(this.$el.closest('html').length === 0) {
        this.remove();
        return;
      }
      var now = new Date(),
          newTotalSecsLeft;
      // Create an offset date object
      newTotalSecsLeft = this.finalDate.getTime() - now.getTime(); // Millisecs
      // Calculate the remaining time
      newTotalSecsLeft = Math.ceil(newTotalSecsLeft / 1000); // Secs
      // If is not have to elapse set the finish
      newTotalSecsLeft = !this.options.elapse && newTotalSecsLeft < 0 ? 0 :
        Math.abs(newTotalSecsLeft);
      // Do not proceed to calculation if the seconds have not changed or
      // during the first tick
      if (this.totalSecsLeft === newTotalSecsLeft || this.firstTick) {
        this.firstTick = false;
        return;
      } else {
        this.totalSecsLeft = newTotalSecsLeft;
      }
      // Check if the countdown has elapsed
      this.elapsed = (now >= this.finalDate);
      // Calculate the offsets
      this.offset = {
        seconds     : this.totalSecsLeft % 60,
        minutes     : Math.floor(this.totalSecsLeft / 60) % 60,
        hours       : Math.floor(this.totalSecsLeft / 60 / 60) % 24,
        days        : Math.floor(this.totalSecsLeft / 60 / 60 / 24) % 7,
        daysToWeek  : Math.floor(this.totalSecsLeft / 60 / 60 / 24) % 7,
        daysToMonth : Math.floor(this.totalSecsLeft / 60 / 60 / 24 % 30.4368),
        weeks       : Math.floor(this.totalSecsLeft / 60 / 60 / 24 / 7),
        weeksToMonth: Math.floor(this.totalSecsLeft / 60 / 60 / 24 / 7) % 4,
        months      : Math.floor(this.totalSecsLeft / 60 / 60 / 24 / 30.4368),
        years       : Math.abs(this.finalDate.getFullYear()-now.getFullYear()),
        totalDays   : Math.floor(this.totalSecsLeft / 60 / 60 / 24),
        totalHours  : Math.floor(this.totalSecsLeft / 60 / 60),
        totalMinutes: Math.floor(this.totalSecsLeft / 60),
        totalSeconds: this.totalSecsLeft
      };
      // Dispatch an event
      if(!this.options.elapse && this.totalSecsLeft === 0) {
        this.stop();
        this.dispatchEvent('finish');
      } else {
        this.dispatchEvent('update');
      }
    },
    dispatchEvent: function(eventName) {
      var event = $.Event(eventName + '.countdown');
      event.finalDate     = this.finalDate;
      event.elapsed       = this.elapsed;
      event.offset        = $.extend({}, this.offset);
      event.strftime      = strftime(this.offset);
      this.$el.trigger(event);
    }
  });
  // Register the jQuery selector actions
  $.fn.countdown = function() {
    var argumentsArray = Array.prototype.slice.call(arguments, 0);
    return this.each(function() {
      // If no data was set, jQuery.data returns undefined
      var instanceNumber = $(this).data('countdown-instance');
      // Verify if we already have a countdown for this node ...
      // Fix issue #22 (Thanks to @romanbsd)
      if (instanceNumber !== undefined) {
        var instance = instances[instanceNumber],
          method = argumentsArray[0];
        // If method exists in the prototype execute
        if(Countdown.prototype.hasOwnProperty(method)) {
          instance[method].apply(instance, argumentsArray.slice(1));
        // If method look like a date try to set a new final date
        } else if(String(method).match(/^[$A-Z_][0-9A-Z_$]*$/i) === null) {
          instance.setFinalDate.call(instance, method);
          // Allow plugin to restart after finished
          // Fix issue #38 (thanks to @yaoazhen)
          instance.start();
        } else {
          $.error('Method %s does not exist on jQuery.countdown'
            .replace(/\%s/gi, method));
        }
      } else {
        // ... if not we create an instance
        new Countdown(this, argumentsArray[0], argumentsArray[1]);
      }
    });
  };
});
